1、mysql在隔离级别为 REPEATABLE-READ（可重复读）时，会出现幻读，但并不是任何情况下都会产生幻读。如果其它事务添加了一条记录，当前事务重新查询并不会有幻读，
如果当前事务更新时的条件包含在其它事务添加的那条记录中，再次查询时，则会出现幻读。

2、InnoDB会根据隔离级别在需要的时候自动加锁，属于隐式锁定。锁只有在commit或rollback时才会释放，InnoDB也支持通过特定语句显示锁定，
select ... lock in share mode; （共享锁，可以和其它事务的共享锁同时存在）
select ... for update;  (排他锁，只允许当前事务修改数据，直到事务结束,无法和其它事务的共享锁和排他锁同时存在)

3、 show table status; -- 查看表的状态
Name：
    表名 
Engine：
    存储引擎 
Row_format：
    行的格式。对于MyISAM表，可选的值为Dynamic、Fixed或者Compressed。
    Dynamic的行长度是可变的，一般包含可变长度的字段，如VARCHAR或BLOB。Fixed
    的行长度则是固定的，只包含固定长度的列，如CHAR和INTEGER。Compressed 的行
    则只在压缩表中存在。
Rows:
    表中的行数。对于MyISAM和其他一些存储引擎，该值是精确的，但对于InnoDB,
    该值是估计值。
Avg_ row_ length:
    平均每行包含的字节数。
Data_ length:
    表数据的大小(以字节为单位)。
Max_data_length:
    表数据的最大容量，该值和存储引擎有关。
Index_length:
    索引的大小(以字节为单位)。
Data_free:
    对于MyISAM表，表示已分配但目前没有使用的空间。这部分空间包括了之前删除
    的行，以及后续可以被INSERT利用到的空间。
Auto_increment:
    下一个AUTO INCREMENT 的值。
Create_time:
    表的创建时间。
Update_time:
    表数据的最后修改时间。
Check_time:
    使用CHECK TABLE 命令或者myisamchk工具最后一次检查表的时间。
Collation:
    表的默认字符集和字符列排序规则。
Checksum:
    如果启用，保存的是整个表的实时校验和。
Create_ options:
    创建表时指定的其他选项。
Comment:
    该列包含了一些其他的额外信息。对于MyISAM表,保存的是表在创建时带的注释。
    对于InnoDB表，则保存的是InnoDB表空间的剩余空间信息。如果是一个视图，则
    该列包含“VIEW" 的文本字样。

4、尽量不要有 NULL 值的列

5、索引字段如果比较长，可以使用hash之后的字段作为索引，如：
SELECT id FROM url WHERE url="http://www.mysql.com"
and url_crc=CRC32("http://www.mysql.com" );
这样做需要维护url_crc字段，可以使用触发器维护这个字段。
为了解决hash冲突，一定要在 where条件中带上常量值条件 url = "http://www.mysql.com"

6、覆盖索引
通常大家都会根据查询的WHERE条件来创建合适的索引，不过这只是索引优化的一个方
面。设计优秀的索引应该考虑到整个查询，而不单单是WHERE条件部分。索引确实是一
种查找数据的高效方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不
再需要读取数据行。如果索引的叶子节点中已经包含要查询的数据，那么还有什么必要
再回表查询呢?如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们就称
之为“覆盖索引” 。覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下
如果查询只需要扫描索引 而无须回表，会带来多少好处，在执行计划中可以看到 Extra 列为 Using Index

7、mysql无法使用范围列后面的其它索引

8、延迟关联
对于翻页比较靠后的查询
因为随着偏移量的增加，MySQL需要花费大量的时间来扫描需要丢弃的数据。反范式化、预先计算和缓存可能是解决这类
查询的仅有策略。一个更好的办法是限制用户能够翻页的数量，实际上这对用户体验的
影响不大，因为用户很少会真正在乎搜索结果的第10000页。
优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要.
的主键，再根据这些主键关联原表获得需要的行。这可以减少MySQL扫描那些需要丢
弃的行数。下面这个查询显示了如何高效地使用(sex, rating)索引进行排序和分页:
SELECT <cols> FROM profiles INNER JOIN (
SELECT <primary key cols> FROM profiles
WHERE x.sex='M' ORDER BY rating LIMIT 100000, 10
AS xUSING(<primary key cols>);

9、表损坏修复
表损坏(corruption) 是很糟糕的事情。对于MyISAM存储引擎，表损坏通常是系统崩
溃导致的。其他的引擎也会由于硬件问题、MySQL本身的缺陷或者操作系统的问题导
致索引损坏。
损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会
导致数据库的崩溃。如果你遇到了古怪的问题。例如一些不应该发生的错误，可以
尝试运行CHECK TABLE 来检查是否发生了表损坏(注意有些存储引擎不支持该命令;而
有些引擎则支持以不同的选项来控制完全检查表的方式)。CHECK TABLE 通常能够找出大
多数的表和索引的错误。
可以使用REPAIR TABLE命令来修复损坏的表,但同样不是所有的存储引擎都支持该命令。
如果存储引擎不支持，也可通过一个不做任何操作(no-op) 的ALTER操作来重建表，例
如修改表的存储引擎为当前的引擎。下面是一个针对InnoDB表的例子:
ALTER TABLE innodb_tbl ENGINE=INNODB;
如果InnoDB引擎的表出现了损坏，那么一定是发生了严重的错误，需要立刻调查一下
原因。InnoDB 一般不会出现损坏。InnoDB 的设计保证了它并不容易被损坏。如果发生
损坏，一般要么是数据库的硬件问题例如内存或者磁盘问题(有可能)，要么是由于数
据库管理员的错误例如在MySQL外部操作了数据文件(有可能)，抑或是InnoDB本身
的缺陷(不太可能)。常见的类似错误通常是由于尝试使用rsync备份InnoDB导致的。
不存在什么查询能够让InnoDB表损坏，也不用担心暗处有“陷阱”。如果某条查询导致
InnoDB数据的损坏，那一定是遇到了bug，而不是查询的问题。
如果遇到数据损坏，最重要的是找出是什么导致了损坏，而不只是简单地修复，否则
很有可能还会不断地损坏。可以通过设置innodb_force_recovery 参数进人InnoDB的
强制恢复模式来修复数据，更多细节可以参考MySQL手册。另外，还可以使用开源的
InnoDB数据恢复工具箱(InnoDB Data Recovery Toolkit)直接从InnoDB数据文件恢复出
数据(下载地址: htp://www.percona. com/software/mysql-innodb-data-recovery.tools/)。

10、查看索引基数
show index from 表名，其中的Cardinality列代表不重复的值的数量
InnoDB会在表首次打开，或者执行ANALYZE TABLE, 抑或表的大小发生非常大的变化
(大小变化超过十六分之一或者新插入了20亿行都会触发)的时候计算索引的统计信息。
InnoDB在打开某些INFORMATION SCHEMA表， 或者使用SHOW TABLE STATUS 和SHOW
INDEX，抑或在MySQL客户端开启自动补全功能的时候都会触发索引统计信息的更新。
如果服务器上有大量的数据，这可能就是个很严重的问题，尤其是当I/O比较慢的时候。
客户端或者监控程序触发索引信息采样更新时可能会导致大量的锁，并给服务器带来很
多的额外压力，这会让用户因为启动时间漫长而沮丧。只要SHOW INDEX查看索引统计信
息，就一定会触发统计信息的更新。可以关闭innodb_stats_on_metadata 参数来避免上
面提到的问题。
如果使用Percona版本，使用的就是XtraDB引擎而不是原生的InnoDB引擎，那么可以
通过innodb_stats_auto_update 参数来禁止通过自动采样的方式更新索引统计信息，这
时需要手动执行ANALYZE TABLE 命令来更新统计信息。如果某些查询执行计划很不稳定
的话，可以用该办法固化查询计划。我们当初引入这个参数也正是为了解决一些客户的这种问题
如果想要更稳定的执行计划，并在系统重启后更快地生成这些统计信息，那么可以使用
系统表来持久化这些索引统计信息。甚至还可以在不同的机器间迁移索引统计信息，这
样新环境启动时就无须再收集这些数据。在Percona 5.1版本和官方的5.6版本都已经加
入这个特性。在Percona版本中通过innodb_use_sys_stats_table 参数可以启用该特性，
官方5.6版本则通过innodb_analyze_is_persistent参数控制。
一.旦关闭索引统计信息的自动更新，那么就需要周期性地使用ANALYZE TABLE 来手动更
新。否则，索引统计信息就会永远不变。如果数据分布发生大的变化，可能会出现一些
很糟糕的执行计划。

11、碎片整理
可以通过执行OPTIMIZE TABLE 或者导出再导入的方式来重新整理数据。这对多数存储引
擎都是有效的。对于一些存储引擎如MyISAM，可以通过排序算法重建索引的方式来消
除碎片。老版本的InnoDB没有什么消除碎片化的方法。不过最新版本InnoDB新增了“在
线”添加和删除索引的功能，可以通过先删除，然后再重新创建索引的方式来消除索引的碎片化。
对于那些不支持OPTIMIZE TABLE 的存储引擎，可以通过一个不做任何操作(no-op) 的
ALTER TABLE 操作来重建表。只需要将表的存储引擎修改为当前的引擎即可:
mysql> ALTER TABLE <table> ENGINE=<engine> ;
对于开启了expand_fast_index_creation 参数的Percona Server,按这种方式重建表，
则会同时消除表和索引的碎片化。但对于标准版本的MySQL则只会消除表(实际上是
聚簇索引)的碎片化。可用先删除所有索引，然后重建表，最后重新创建索引的方式模
拟Percona Server的这个功能。 应该通过一些实际测量而不是随意假设来确定是否
需要消除索引和表的碎片化。Percona 的XtraBackup有个--stats参数以非备份的
方式运行，而只是打印索引和表的统计情况， 包括页中的数据量和空余空间。
这可以用来确定数据的碎片化程度。另外也要考虑数据是否已经达到稳定状态，如果你
进行碎片整理将数据压缩到一起，可能反而会导致后续的更新操作触发一系列的页分裂
和重组，这会对性能造成不良的影响(直到数据再次达 到新的稳定状态)。

12、执行计划访问类型
在EXPLAIN语句中的type列反应了访问类型。访问类型有很多种，从全表扫描到索引扫
描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度是从慢到快，扫描的
行数也是从小到大。你不需要记住这些访问类型，但需要明白扫描表、扫描索引、范围
访问和单值访问的概念。

13、查询状态
对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态，该状态表示了
MySQL当前正在做什么。有很多种方式能查看当前的状态，最简单的是使用SHOW FULL
PROCESSLIST命令(该命令返回结果中的Command列就表示当前的状态)。在一个查询的
生命周期中，状态会变化很多次。MySQL官方手册中对这些状态值的含义有最权威的
解释，下面将这些状态列出来，并做一个简单的解释。
Sleep
线程正在等待客户端发送新的请求。
Query
线程正在执行查询或者正在将结果发送给客户端。
Locked
在MySQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如
InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型，
的状态，但在其他没有行锁的引擎中也经常会出现。
Analyzing and statistics
线程正在收集存储引擎的统计信息，并生成查询的执行计划。
Copying to tmp table [on disk]
线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是
在做GROUP BY操作，要么是文件排序操作，或者是UNION操作。如果这个状态后面.
还有“ondisk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。
Sorting result
线程正在对结果集进行排序。
Sending data
这表示多种情况:线程可能在多个状态之间传送数据，或者在生成结果集，或者在
向客户端返回数据。

14、排序优化
如果mysql不能使用索引排序，则自己会进行排序（filesort）

15、查询缓存

16、复制

